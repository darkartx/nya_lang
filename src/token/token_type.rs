use std::fmt;

// Token type
#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum TokenType {
    Eof,
    Let,
    Const,
    Fn,
    Async,
    Await,
    Return,
    If,
    Else,
    For,
    While,
    Break,
    Continue,
    Class,
    Constructor,
    Extends,
    Static,
    Operator,
    Get,
    Set,
    Import,
    From,
    Export,
    Try,
    Catch,
    Finally,
    True,
    False,
    Null,
    Identifier,
    IntNumber,
    FloatNumber,
    String,
    Plus,
    Minus,
    Mult,
    Div,
    Mod,
    Eq,
    Neq,
    Lt,
    Lte,
    Gt,
    Gte,
    And,
    Or,
    Not,
    Assign,
    PlusAssign,
    MinusAssign,
    MultAssign,
    DivAssign,
    Semicolon,
    Comma,
    Dot,
    Lparen,
    Rparen,
    Lbrace,
    Rbrace,
    At,
    Comment,
    New,
    Range,
    NewLine,
}

impl fmt::Display for TokenType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        use TokenType::*;

        match self {
            Eof => write!(f, "EOF"),
            Let => write!(f, "LET"),
            Const => write!(f, "CONST"),
            Fn => write!(f, "FN"),
            Async => write!(f, "ASYNC"),
            Await => write!(f, "AWAIT"),
            Return => write!(f, "RETURN"),
            If => write!(f, "IF"),
            Else => write!(f, "ELSE"),
            For => write!(f, "FOR"),
            While => write!(f, "WHILE"),
            Break => write!(f, "BREAK"),
            Continue => write!(f, "CONTINUE"),
            Class => write!(f, "CLASS"),
            Constructor => write!(f, "CONSTUCTOR"),
            Extends => write!(f, "EXTENDS"),
            Static => write!(f, "STAIC"),
            Operator => write!(f, "OPERATOR"),
            Get => write!(f, "GET"),
            Set => write!(f, "SET"),
            Import => write!(f, "IMPORT"),
            From => write!(f, "FROM"),
            Export => write!(f, "EXPORT"),
            Try => write!(f, "TRY"),
            Catch => write!(f, "CATCH"),
            Finally => write!(f, "FINALLY"),
            True => write!(f, "TRUE"),
            False => write!(f, "FALSE"),
            Null => write!(f, "NULL"),
            Identifier => write!(f, "IDENT"),
            IntNumber => write!(f, "INT"),
            FloatNumber => write!(f, "FLOAT"),
            String => write!(f, "STRING"),
            Plus => write!(f, "PLUS"),
            Minus => write!(f, "MINUS"),
            Mult => write!(f, "MULT"),
            Div => write!(f, "DIV"),
            Mod => write!(f, "MOD"),
            Eq => write!(f, "EQ"),
            Neq => write!(f, "NEQ"),
            Lt => write!(f, "LT"),
            Lte => write!(f, "LTE"),
            Gt => write!(f, "GT"),
            Gte => write!(f, "GTE"),
            And => write!(f, "AND"),
            Or => write!(f, "OR"),
            Not => write!(f, "NOT"),
            Assign => write!(f, "ASSIGN"),
            PlusAssign => write!(f, "PLUS_ASSIGN"),
            MinusAssign => write!(f, "MINUS_ASSIGN"),
            MultAssign => write!(f, "MULT_ASSIGN"),
            DivAssign => write!(f, "DIV_ASSIGN"),
            Semicolon => write!(f, "SEMICOLON"),
            Comma => write!(f, "COMMA"),
            Dot => write!(f, "DOT"),
            Lparen => write!(f, "LPAREN"),
            Rparen => write!(f, "RPAREN"),
            Lbrace => write!(f, "LBRACE"),
            Rbrace => write!(f, "RBRANCE"),
            At => write!(f, "AT"),
            Comment => write!(f, "COMMENT"),
            New => write!(f, "NEW"),
            Range => write!(f, "RANGE"),
            NewLine => write!(f, "NL"),
        }
    }
}
